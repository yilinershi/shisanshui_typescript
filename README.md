## 运行
* 先安装typescript,命令:`npm install -g typescript`
* 再安装type-node,命令：`npm install -g ts-node`
* 跳转到该项目目录：`cd {your workspace}/shisanshui_algorithm`
* 运行Api_Example中的例子：`ts-node "{your workspace}/shisanshui_algorithm/Algorithm/Api_Example.ts"`

## 说明
* 所有计算基于poker这个最小结构单位（方便统一计算）
* 将poker的list转换成二叉树的tree:`new Tree(pokers)`
* 计算特殊牌型方法：`Api.CalSpecial(tree:Tree)`
* 计算普通牌型方法：`Api.CalNormal(tree:Tree)`，结果返回所有的牌型组合，按照AI的优先顺序排列，如下示例，牌型[0]为最优解
* 提供了十六进制转poker方法：`Api.PokersFromAscii(nums: Array<number>)`，可将16进制定义的扑克牌转成`Array<Poker>`

## 普通牌型运行结果示例
```
测试开始：♦A,♦2,♦3,♦4,♦5,♥4,♠5,♥6,♥7,♥8,♥9,♥T,♦K,Desc=普通牌型【两同花顺1】
牌型[0]=> 结果：{上:【乌龙】= {♥4♠5♦K},中:【同花顺】= {♥6♥7♥8♥9♥T},下:【同花顺】= {♦2♦3♦4♦5♦A},好牌值=【32】}
牌型[1]=> 结果：{上:【对子】= {♥4♦5♠5},中:【同花】= {♦2♦3♦4♦K♦A},下:【同花顺】= {♥6♥7♥8♥9♥T},好牌值=【22】}
牌型[2]=> 结果：{上:【乌龙】= {♠5♥T♦K},中:【同花】= {♥4♥6♥7♥8♥9},下:【同花顺】= {♦2♦3♦4♦5♦A},好牌值=【20】}
牌型[3]=> 结果：{上:【乌龙】= {♥4♠5♦K},中:【顺子】= {♦2♦3♦4♦5♦A},下:【同花顺】= {♥6♥7♥8♥9♥T},好牌值=【19】}
牌型[4]=> 结果：{上:【对子】= {♦4♥4♠5},中:【同花】= {♥6♥7♥8♥9♥T},下:【同花】= {♦2♦3♦5♦K♦A},好牌值=【15】}
牌型[5]=> 结果：{上:【对子】= {♦4♥4♥T},中:【顺子】= {♠5♥6♥7♥8♥9},下:【同花】= {♦2♦3♦5♦K♦A},好牌值=【14】}
牌型[6]=> 结果：{上:【乌龙】= {♦2♥4♠5},中:【同花】= {♥6♥7♥8♥9♥T},下:【同花】= {♦3♦4♦5♦K♦A},好牌值=【13】}
牌型[7]=> 结果：{上:【乌龙】= {♦2♥4♠5},中:【顺子】= {♥6♥7♥8♥9♥T},下:【同花】= {♦3♦4♦5♦K♦A},好牌值=【12】}
牌型[8]=> 结果：{上:【乌龙】= {♥9♥T♦K},中:【顺子】= {♥4♠5♥6♥7♥8},下:【顺子】= {♦2♦3♦4♦5♦A},好牌值=【11】}
牌型[9]=> 结果：{上:【乌龙】= {♥9♥T♦K},中:【乌龙】= {♦2♥4♠5♥8♦A},下:【顺子】= {♦3♦4♦5♥6♥7},好牌值=【7】}
测试结束,耗时：5毫秒
--------------------------------------------
测试开始：♦A,♦2,♦3,♦4,♦6,♦7,♦8,♦9,♦Q,♣6,♣J,♣8,♣9,Desc=普通牌型【3对，A同花】
牌型[0]=> 结果：{上:【对子】= {♦9♣9♣J},中:【两对】= {♦6♣6♦7♦8♣8},下:【同花】= {♦2♦3♦4♦Q♦A},好牌值=【12】}
牌型[1]=> 结果：{上:【对子】= {♦6♣6♣J},中:【对子】= {♦2♦3♦8♣8♣9},下:【同花】= {♦4♦7♦9♦Q♦A},好牌值=【11】}
牌型[2]=> 结果：{上:【乌龙】= {♦4♣6♣J},中:【两对】= {♦3♦8♣8♦9♣9},下:【同花】= {♦2♦6♦7♦Q♦A},好牌值=【10】}
牌型[3]=> 结果：{上:【乌龙】= {♦7♣8♣J},中:【对子】= {♦2♦4♣6♦9♣9},下:【同花】= {♦3♦6♦8♦Q♦A},好牌值=【9】}
牌型[4]=> 结果：{上:【乌龙】= {♦7♣8♣9},中:【乌龙】= {♦2♦3♦4♣6♣J},下:【同花】= {♦6♦8♦9♦Q♦A},好牌值=【8】}
测试结束,耗时：6毫秒
--------------------------------------------
```